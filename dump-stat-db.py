#!/usr/bin/python3

# This script allows to decode .db files created by the stat branch of libezsp
# In statistic collection mode, a .db file will be created for each known source IDs, and will contain timestamps and data about received and missed GP report frames.

import sys
import os
import struct
import time
import datetime

import argparse
import logging

progname = os.path.basename(sys.argv[0])

arch_endianness = '<'

class SourceIdData:
	struct_fmt = 'HHL' # std::time_t lastSeenTimeStamp, uint16_t offlineSequenceNo, uint16_t nbSuccessiveMisses, uint32_t nbSuccessiveRx
	
	def __init__(self, arch_time_t_sz, data):
		struct_fmt_data = SourceIdData.unpack_fmt(arch_time_t_sz)
		u = struct.unpack(struct_fmt_data, data)
		self.last_seen_time_stamp = time.gmtime(u[0])
		self.offline_sequence_no = u[1]
		self.nb_successive_misses = u[2]
		self.nb_successive_rx = u[3]
	
	@classmethod
	def unpack_fmt(cls, arch_time_t_sz):
		if arch_time_t_sz == 4:
			arch_time_t_fmt = 'L'
		elif arch_time_t_sz == 8:
			arch_time_t_fmt = 'Q'
		else:
			raise Exception('UnsupportedArch')
		return arch_endianness + arch_time_t_fmt + SourceIdData.struct_fmt
	
	@classmethod
	def data_len(cls, arch_time_t_sz):
		return struct.calcsize(SourceIdData.unpack_fmt(arch_time_t_sz))
	
	def __repr__(self):
		if self.offline_sequence_no == 0xffff:
			offline_sequence_repr='(startup)'
		else:
			offline_sequence_repr=str(self.offline_sequence_no)
		if self.nb_successive_misses == 0xffff:
			nb_successive_misses_repr='(startup)'
		else:
			nb_successive_misses_repr=str(self.nb_successive_misses)
		return 'SourceIdData(' + time.strftime('%Y%m%d %H:%M:%S', self.last_seen_time_stamp) + \
		       ',seq_no=' + offline_sequence_repr + \
		       ',missed=' + nb_successive_misses_repr + \
		       ',rx=' + str(self.nb_successive_rx) + ')'
	
	def is_start_marker(self):
		return self.offline_sequence_no == 0xffff and self.nb_successive_misses == 0xffff

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description="This scripts allows to decode .db files generated by libezsp in stat dump mode.", prog=progname)
	parser.add_argument('-T', '--time_t_sz', type=int, help='size of a time_t value in bytes', default=8)
	parser.add_argument('-d', '--debug', action='store_true', help='display debug info')
	parser.add_argument("input", help="the .db file to open")
	args = parser.parse_args()
	
	logging.basicConfig()

	logger = logging.getLogger(__name__)

	if args.debug:
		logger.setLevel(logging.DEBUG)
	else:
		logger.setLevel(logging.INFO)

	handler = logging.StreamHandler()
	handler.setFormatter(logging.Formatter("%(levelname)s %(asctime)s %(name)s():%(lineno)d %(message)s"))
	logger.addHandler(handler)
	logger.propagate = False

	logger.debug(progname + ": Starting")
	
	results = []
	with open(args.input, 'rb') as f:
		eof_found = False
		while not eof_found:
			data = f.read(SourceIdData.data_len(args.time_t_sz))
			if not data:
				eof_found = True
			else:
				results.append(SourceIdData(args.time_t_sz, data))
	
	last_ts = None
	for r in results:
		time_diff = ''
		if last_ts is not None:
			new_ts = r.last_seen_time_stamp
			time_diff_s = time.mktime(new_ts) - time.mktime(last_ts)
			time_diff_delta = datetime.timedelta(seconds=time_diff_s)
			time_diff = ' (diff->' + str(time_diff_delta) + 's)'
		last_ts = r.last_seen_time_stamp
		print(str(r)+time_diff)